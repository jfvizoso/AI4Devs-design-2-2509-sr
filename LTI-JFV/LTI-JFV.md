# LTI - The Future of Talent Acquisition

## 1. Brief Description of LTI Software

**LTI (Linked Talent Intelligence)** is a next-generation Applicant Tracking System (ATS) designed to transform recruitment from a transactional process into a strategic, collaborative, and human-centric experience. 

Unlike legacy systems that act as static repositories for resumes, LTI is an **AI-native ecosystem** that actively orchestrates the hiring lifecycle. It seamlessly bridges the gap between recruiters, hiring managers, and candidates through real-time collaboration, intelligent automation, and predictive insights. LTI is built to eliminate the "black hole" of recruitment, ensuring transparency, speed, and precision in every hire.

## 2. Added Value

LTI delivers value by addressing the core inefficiencies and frustrations of modern recruitment:

*   **For HR & Recruiters:**
    *   **Zero-Admin Workflow:** Drastically reduces manual tasks (scheduling, screening, email follow-ups) by up to 70% through autonomous agents that handle logistics.
    *   **Deep Talent Insights:** Moves beyond keyword matching to semantic understanding of skills and potential, surfacing hidden gems that traditional filters miss.

*   **For Hiring Managers:**
    *   **Frictionless Collaboration:** No more email threads. Managers collaborate in a shared, Slack-like workspace within the candidate profile, enabling real-time feedback, @mentions, and instant decision-making.
    *   **Predictive Quality of Hire:** AI analyzes team composition and candidate attributes to predict cultural add and performance potential before the offer is made.

*   **For Candidates:**
    *   **Transparent Journey:** A "FedEx-style" tracking portal gives candidates real-time visibility into their application status, eliminating ghosting and anxiety.
    *   **Instant Engagement:** AI-driven concierge provides 24/7 interaction, answering questions and scheduling interviews instantly via their preferred channel (WhatsApp, SMS, Email).

## 3. Competitive Advantages

LTI differentiates itself from market leaders (like Greenhouse, Lever, and Workday) through three key pillars:

### üöÄ A. "True AI" vs. "Add-on AI"
While competitors bolt on basic AI features, LTI is **AI-native**. Our core engine uses advanced Large Language Models (LLMs) trained on recruitment data to:
*   **Auto-Interview:** Conduct initial voice or chat-based screening interviews that adapt to candidate responses.
*   **Bias Neutralization:** actively rewrites job descriptions and anonymizes profiles during initial review to ensure diverse hiring.
*   **Smart Sourcing:** Proactively scans the open web to identify and engage passive candidates who match the "DNA" of your top performers.

### ü§ù B. Radical Collaboration
We treat hiring as a team sport. LTI replaces the clunky approval chains of legacy ATS with **synchronous collaboration hubs**.
*   **Live Scorecards:** Interviewers can see each other's notes in real-time (optional) or aggregate them instantly post-interview to reach consensus faster.
*   **Integrated Workspace:** Full functionality embedded within Microsoft Teams and Slack, so managers never have to log into a separate "HR tool."

### üîÆ C. Predictive Ecosystem
LTI doesn't just track what happened; it predicts what *will* happen.
*   **Attrition Risk Analysis:** Flags candidates who show signs of being "high flight risk" based on career history patterns.
*   **Time-to-Fill Forecasting:** Tells you exactly how long a role will take to fill based on current market conditions, allowing for better resource planning.

## 4. Main Functions

LTI is built around four core functional modules, each designed to maximize efficiency, collaboration, and intelligence.

### üß† A. AI-Driven Sourcing & Screening (The "Talent Engine")
This module automates the top of the funnel, ensuring recruiters spend time on *people*, not profiles.
*   **Semantic Match & Rank:** Instead of keyword counting, LTI uses NLP to understand the *meaning* of a resume. It ranks candidates by "Fit Score" (0-100%) based on skills, experience, and potential, highlighting *why* a candidate is a good match.
*   **Passive Candidate Crawler:** An autonomous agent that scans public data (LinkedIn, GitHub, Behance) to find passive candidates who match the job criteria and automatically drafts personalized outreach messages.
*   **Blind Screening Mode:** A toggle that anonymizes candidate profiles (hiding name, gender, university, photo) during the initial review phase to eliminate unconscious bias and focus purely on merit.
*   **Smart Chatbot Assistant:** A 24/7 candidate concierge that answers FAQs, collects missing information, and conducts initial "knockout" questions via WhatsApp or SMS.

### ü§ù B. Collaborative Hiring Workspace (The "War Room")
A centralized hub where hiring teams align, discuss, and decide in real-time.
*   **Slack/Teams Integration:** Full bi-directional sync. Managers can approve job reqs, review candidate summaries, and submit interview feedback directly from their chat app without logging into the ATS.
*   **Live Interview Cockpit:** A split-screen interface for interviewers showing the candidate's profile, a structured question bank, and a shared notepad where interviewers can see each other's notes in real-time (optional).
*   **Async Video Debriefs:** Instead of scheduling another meeting, interviewers can record short 30-second video summaries of their impressions, which are attached to the candidate's profile for the hiring manager to review.

### ‚ö° C. Automated Scheduling & Logistics (The "Auto-Pilot")
Eliminates the back-and-forth of scheduling, handling complex logistics automatically.
*   **Smart Calendar Overlay:** LTI overlays the calendars of all interviewers to find optimal slots. It then sends the candidate a dynamic link to book their own time, automatically handling time zone conversions.
*   **Interview Rescheduling Bot:** If a candidate or interviewer cancels, the bot automatically reaches out to both parties to find the next best time, updating calendar invites without recruiter intervention.
*   **Offer Letter Generator:** Auto-populates offer letters with approved salary data and sends them for e-signature (DocuSign integration), tracking when the candidate views and signs.

### üìä D. Predictive Talent Analytics (The "Oracle")
Turns data into foresight to improve hiring strategy.
*   **Quality of Hire Prediction:** Uses historical data to predict how successful a candidate will be in a specific role/team, flagging potential risks (e.g., "Candidates with this profile have a 20% higher attrition rate in this department").
*   **Diversity Pipeline Tracker:** Real-time dashboards that visualize the diversity of the candidate pool at every stage, alerting recruiters if the pipeline becomes unbalanced so they can course-correct immediately.
*   **Market Pulse:** Benchmarks salary offers against real-time market data to ensure competitiveness, flagging if an offer is too low to close the candidate.

## 5. Lean Canvas

| **Problem** | **Solution** | **Unique Value Proposition** | **Unfair Advantage** | **Customer Segments** |
| :--- | :--- | :--- | :--- | :--- |
| 1. **Inefficient Processes:** Recruiters drown in admin (scheduling, screening), leading to slow hiring. <br> 2. **Black Hole Experience:** Candidates are ghosted and frustrated by opaque processes. <br> 3. **Poor Collaboration:** Hiring managers and recruiters work in silos (email/spreadsheets). <br> 4. **Bad Hires:** Decisions based on gut feel rather than data, leading to high attrition. | 1. **AI Automation:** Autonomous agents for sourcing, screening, and scheduling. <br> 2. **Transparent Portal:** Real-time status tracking for candidates. <br> 3. **Collaborative Hub:** Slack-like workspace for instant team alignment. <br> 4. **Predictive Analytics:** Data-driven insights on quality of hire and team fit. | **The First "Self-Driving" Recruitment Platform.** <br><br> LTI transforms the ATS from a passive filing cabinet into an active, intelligent partner that predicts, automates, and orchestrates the entire hiring lifecycle. | 1. **Proprietary AI Models:** Trained on niche recruitment datasets for superior matching accuracy. <br> 2. **Seamless Ecosystem:** Native integration with daily tools (Slack, Teams, Zoom) unlike legacy competitors. <br> 3. **Predictive Engine:** Ability to forecast time-to-fill and attrition risk. | 1. **Mid-Market Tech Companies:** High growth, need speed, value candidate experience. <br> 2. **Remote-First Organizations:** Need strong digital collaboration tools. <br> 3. **Forward-Thinking Enterprise:** Looking to modernize legacy HR stacks (Workday/Oracle alternative). |
| | | | | |
| **Key Metrics** | | | | **Channels** |
| 1. **Time-to-Hire:** Reduction in days to fill a role. <br> 2. **Candidate Net Promoter Score (cNPS):** Satisfaction of applicants. <br> 3. **Recruiter Efficiency:** Hours saved on admin tasks per week. <br> 4. **Quality of Hire:** Retention rate of new hires after 12 months. | | | | 1. **Direct Sales:** Targeted outreach to HR leaders and CTOs. <br> 2. **Content Marketing:** Thought leadership on "The Future of Hiring" (Whitepapers, Webinars). <br> 3. **Partnerships:** Integration partners (Slack, Microsoft, LinkedIn). <br> 4. **Product-Led Growth:** Free trial for small teams/startups. |
| | | | | |
| **Cost Structure** | | | | **Revenue Streams** |
| 1. **R&D:** Heavy investment in AI/LLM development and infrastructure. <br> 2. **Sales & Marketing:** Customer acquisition costs (CAC). <br> 3. **Cloud Infrastructure:** Hosting and data processing costs. <br> 4. **Customer Success:** Onboarding and support teams. | | | | 1. **SaaS Subscription:** Tiered pricing based on company size/seats (Starter, Growth, Enterprise). <br> 2. **Add-on Modules:** Premium AI features (e.g., advanced sourcing bot) as upsells. <br> 3. **API Access:** Enterprise API usage fees for custom integrations. |

## 6. Main Use Cases

Here are the three primary use cases that demonstrate the core value of LTI for its main users.

### Use Case 1: AI-Powered Sourcing & Initial Screening
**Actor:** Recruiter (Sarah)
**Goal:** Find and shortlist qualified candidates for a "Senior React Developer" role without manual searching.

**Flow:**
1.  Sarah inputs the job description into LTI.
2.  LTI's **Sourcing Agent** analyzes the requirements and scans LinkedIn, GitHub, and internal databases.
3.  The agent identifies 50 potential matches and ranks them by "Fit Score."
4.  The agent automatically sends a personalized outreach message to the top 20 candidates.
5.  A candidate (Alex) replies with interest.
6.  LTI's **Chatbot** engages Alex via WhatsApp, asks 3 knockout questions (salary, visa, experience), and parses the answers.
7.  If Alex passes, the Chatbot auto-schedules a screening call on Sarah's calendar.

```mermaid
sequenceDiagram
    actor Sarah as Recruiter
    participant LTI as LTI System (AI Agent)
    participant Ext as External Sources (LinkedIn/GitHub)
    actor Alex as Candidate
    participant Cal as Calendar System

    Sarah->>LTI: Upload Job Description
    LTI->>LTI: Analyze Requirements (NLP)
    LTI->>Ext: Scan for Candidates
    Ext-->>LTI: Return Profiles
    LTI->>LTI: Rank & Filter (Fit Score)
    LTI->>Alex: Send Personalized Outreach (Email/InMail)
    Alex-->>LTI: Reply "Interested"
    LTI->>Alex: Start WhatsApp Screening Chat
    Alex-->>LTI: Answer Knockout Questions
    LTI->>LTI: Evaluate Answers (Pass/Fail)
    alt Passed
        LTI->>Cal: Check Sarah's Availability
        LTI->>Alex: Offer Interview Slots
        Alex->>LTI: Select Time
        LTI->>Cal: Book Meeting
        LTI->>Sarah: Notify "Interview Scheduled"
    else Failed
        LTI->>Alex: Send Polite Rejection
    end
```

### Use Case 2: Collaborative Decision Making
**Actor:** Hiring Manager (Mike)
**Goal:** Review interview feedback and make a hiring decision efficiently.

**Flow:**
1.  Mike receives a Slack notification from LTI: "Interview with Alex completed."
2.  Mike clicks "View Summary" in Slack.
3.  LTI presents a **Candidate Card** with the interview recording, a 30-second AI-generated video summary, and the interviewer's scorecard.
4.  Mike @mentions the Lead Engineer in the thread: "@Jen, what did you think of his system design skills?"
5.  Jen replies in the thread.
6.  Mike clicks "Approve for Offer" directly in Slack.
7.  LTI triggers the Offer Generation workflow.

```mermaid
sequenceDiagram
    actor Mike as Hiring Manager
    participant Slack as Slack/Teams Integration
    participant LTI as LTI System
    actor Jen as Lead Engineer

    LTI->>LTI: Process Interview Data (Video/Notes)
    LTI->>Slack: Send Notification "Interview Complete"
    Mike->>Slack: Click "View Summary"
    Slack->>LTI: Request Candidate Data
    LTI-->>Slack: Display Candidate Card (Video/Scorecard)
    Mike->>Slack: Post Comment "@Jen thoughts?"
    Slack->>Jen: Notify Mention
    Jen->>Slack: Reply "Strong on architecture, weak on testing"
    Mike->>Slack: Click "Approve for Offer"
    Slack->>LTI: Update Status to "Offer Stage"
    LTI->>LTI: Trigger Offer Generator
```

### Use Case 3: Transparent Candidate Journey
**Actor:** Candidate (Alex)
**Goal:** Track application status and stay informed without "ghosting."

**Flow:**
1.  Alex applies for a job via the LTI portal.
2.  LTI creates a "Tracker Dashboard" for Alex (similar to a pizza delivery tracker).
3.  Alex logs in and sees his status: "Application Received" -> "AI Screening Passed" -> "Under Review by Manager."
4.  When the status changes to "Interview Requested," Alex receives a push notification.
5.  Alex opens the portal to select a time slot.
6.  After the interview, Alex sees a "Feedback Pending" status with an estimated decision date (predicted by LTI).

```mermaid
sequenceDiagram
    actor Alex as Candidate
    participant Portal as LTI Candidate Portal
    participant LTI as LTI Core System
    participant Notif as Notification Service (Email/SMS)

    Alex->>Portal: Submit Application
    Portal->>LTI: Create Application Record
    LTI-->>Portal: Update Status: "Received"
    LTI->>LTI: Run AI Screening
    LTI-->>Portal: Update Status: "Screening Passed"
    LTI->>Notif: Send Update "You passed the first step!"
    LTI-->>Portal: Update Status: "Under Review"
    Note over LTI: Manager reviews profile
    LTI-->>Portal: Update Status: "Interview Requested"
    LTI->>Notif: Push Notification "Pick a time!"
    Alex->>Portal: Select Interview Slot
    Portal->>LTI: Confirm Booking
    LTI-->>Portal: Update Status: "Interview Scheduled"
    Note over LTI: Interview happens
    LTI-->>Portal: Update Status: "Feedback Pending (Est. 2 days)"
```

## 7. Data Model

The LTI data model is designed to support high-volume recruitment, rich AI metadata, and complex relationship mapping between candidates, jobs, and hiring teams.

### Key Entities & Attributes

#### 1. **Candidate**
Represents the talent profile.
*   `id` (UUID): Unique identifier.
*   `first_name` (String): Candidate's first name.
*   `last_name` (String): Candidate's last name.
*   `email` (String): Primary contact email (Unique).
*   `phone` (String): Contact number.
*   `linkedin_url` (String): Link to public profile.
*   `resume_text` (Text): Full parsed text of the resume for NLP.
*   `skills_vector` (Vector/JSON): AI-generated embedding of skills for semantic search.
*   `created_at` (DateTime): Timestamp of profile creation.

#### 2. **JobPosting**
Represents a specific role opening.
*   `id` (UUID): Unique identifier.
*   `title` (String): Job title (e.g., "Senior React Developer").
*   `department` (String): Department (e.g., "Engineering").
*   `hiring_manager_id` (UUID): FK to User (The owner of the role).
*   `status` (Enum): DRAFT, OPEN, CLOSED, ON_HOLD.
*   `description` (Text): Full job description.
*   `requirements_vector` (Vector/JSON): AI-generated embedding of job requirements.
*   `salary_range_min` (Decimal): Minimum salary.
*   `salary_range_max` (Decimal): Maximum salary.

#### 3. **Application**
The link between a Candidate and a JobPosting.
*   `id` (UUID): Unique identifier.
*   `candidate_id` (UUID): FK to Candidate.
*   `job_id` (UUID): FK to JobPosting.
*   `status` (Enum): APPLIED, SCREENING, INTERVIEW, OFFER, HIRED, REJECTED.
*   `fit_score` (Float): AI-calculated match score (0.0 - 1.0).
*   `ai_summary` (Text): Brief AI-generated summary of why the candidate fits.
*   `current_stage` (String): Current step in the pipeline.
*   `applied_at` (DateTime): Timestamp of application.

#### 4. **Interview**
A scheduled event between a Candidate and Interviewer(s).
*   `id` (UUID): Unique identifier.
*   `application_id` (UUID): FK to Application.
*   `start_time` (DateTime): Scheduled start time.
*   `end_time` (DateTime): Scheduled end time.
*   `type` (Enum): SCREENING, TECHNICAL, BEHAVIORAL, FINAL.
*   `video_link` (String): URL for the meeting (Zoom/Teams).
*   `status` (Enum): SCHEDULED, COMPLETED, CANCELLED.
*   `recording_url` (String): Link to the stored recording.

#### 5. **Feedback**
The scorecard or review left by an interviewer.
*   `id` (UUID): Unique identifier.
*   `interview_id` (UUID): FK to Interview.
*   `interviewer_id` (UUID): FK to User.
*   `rating` (Integer): Overall score (1-5).
*   `pros` (Text): Positive feedback.
*   `cons` (Text): Areas for improvement.
*   `decision` (Enum): STRONG_HIRE, HIRE, NO_HIRE, STRONG_NO_HIRE.
*   `submitted_at` (DateTime): Timestamp.

#### 6. **User**
System users (Recruiters, Hiring Managers, Interviewers).
*   `id` (UUID): Unique identifier.
*   `email` (String): Corporate email.
*   `role` (Enum): ADMIN, RECRUITER, HIRING_MANAGER, INTERVIEWER.
*   `department` (String): User's department.

### Entity Relationship Diagram (ERD)

```mermaid
erDiagram
    Candidate ||--o{ Application : "submits"
    JobPosting ||--o{ Application : "receives"
    User ||--o{ JobPosting : "manages"
    Application ||--o{ Interview : "has"
    Interview ||--|{ Feedback : "generates"
    User ||--o{ Feedback : "writes"
    User ||--o{ Interview : "conducts"

    Candidate {
        UUID id
        String email
        String resume_text
        JSON skills_vector
    }
    JobPosting {
        UUID id
        String title
        UUID hiring_manager_id
        JSON requirements_vector
        Enum status
    }
    Application {
        UUID id
        UUID candidate_id
        UUID job_id
        Float fit_score
        Enum status
    }
    Interview {
        UUID id
        UUID application_id
        DateTime start_time
        Enum type
    }
    Feedback {
        UUID id
        UUID interview_id
        UUID interviewer_id
        Integer rating
        Enum decision
    }
    User {
        UUID id
        String email
        Enum role
    }
```

## 8. High-Level System Design

The LTI architecture follows a **modern, event-driven microservices pattern** to ensure scalability, real-time performance, and seamless AI integration.

### Core Components

1.  **Frontend Clients (SPA & Mobile):**
    *   **Web App (React/Next.js):** The primary interface for recruiters and hiring managers.
    *   **Candidate Portal (Mobile-First):** A lightweight PWA for candidates to track status and schedule interviews.
    *   **Mobile App (React Native):** For hiring managers to review and approve on the go.

2.  **API Gateway (GraphQL Federation):**
    *   Acts as the single entry point, routing requests to appropriate services.
    *   Handles authentication, rate limiting, and request aggregation.

3.  **Core Backend Services (Node.js/Go):**
    *   **Auth Service:** Manages users, roles, and SSO (Okta/Google).
    *   **ATS Core Service:** Handles standard CRUD for Jobs, Candidates, and Applications.
    *   **Scheduling Service:** Integrates with Google/Outlook Calendars to manage bookings.
    *   **Communication Service:** Manages emails, SMS (Twilio), and WhatsApp (Business API).

4.  **AI Engine (Python/FastAPI):**
    *   **LLM Wrapper:** Interfaces with OpenAI/Anthropic for text generation (emails, summaries).
    *   **Vector Database (Pinecone/Milvus):** Stores embeddings for semantic search (matching candidates to jobs).
    *   **Agent Orchestrator (LangChain):** Manages autonomous agents for sourcing and screening.

5.  **Real-Time Layer:**
    *   **WebSocket Server (Socket.io):** Pushes live updates (notifications, typing indicators) to the frontend.
    *   **Event Bus (Kafka/RabbitMQ):** Decouples services, allowing async processing (e.g., "Application Received" event triggers "AI Screening" and "Email Notification").

6.  **Data Storage:**
    *   **PostgreSQL:** Primary relational DB for structured data (Users, Jobs).
    *   **Redis:** Caching layer for high-speed access and session management.
    *   **S3/Blob Storage:** Stores resumes, profile photos, and interview recordings.

### Architecture Diagram (C4 Container)

```mermaid
C4Context
    title System Context Diagram for LTI System

    Person(recruiter, "Recruiter", "Manages job postings and candidate pipeline")
    Person(candidate, "Candidate", "Applies for jobs and tracks status")
    Person(manager, "Hiring Manager", "Reviews candidates and makes decisions")

    System_Boundary(lti_system, "LTI System") {
        Container(web_app, "Web Application", "React, Next.js", "Main interface for internal users")
        Container(portal, "Candidate Portal", "React, PWA", "Interface for applicants")
        Container(api_gateway, "API Gateway", "Apollo GraphQL", "Routes requests and handles auth")
        
        Container(core_service, "Core ATS Service", "Node.js", "Business logic for hiring workflows")
        Container(ai_service, "AI Engine", "Python, FastAPI", "LLM processing and semantic search")
        Container(sched_service, "Scheduling Service", "Go", "Calendar sync and booking logic")
        
        ContainerDb(primary_db, "Primary DB", "PostgreSQL", "Stores core relational data")
        ContainerDb(vector_db, "Vector DB", "Pinecone", "Stores embeddings for matching")
        ContainerDb(cache, "Cache", "Redis", "Session and real-time data")
    }

    System_Ext(linkedin, "LinkedIn API", "Sourcing candidates")
    System_Ext(calendar, "Google/Outlook", "Calendar sync")
    System_Ext(slack, "Slack/Teams", "Notifications and collaboration")
    System_Ext(openai, "LLM Provider", "OpenAI/Anthropic API")

    Rel(recruiter, web_app, "Uses")
    Rel(manager, web_app, "Uses")
    Rel(candidate, portal, "Uses")

    Rel(web_app, api_gateway, "GraphQL/HTTPS")
    Rel(portal, api_gateway, "GraphQL/HTTPS")

    Rel(api_gateway, core_service, "gRPC")
    Rel(api_gateway, ai_service, "gRPC")
    Rel(api_gateway, sched_service, "gRPC")

    Rel(core_service, primary_db, "Reads/Writes")
    Rel(core_service, cache, "Reads/Writes")
    Rel(core_service, slack, "Sends notifications")

    Rel(ai_service, vector_db, "Semantic Search")
    Rel(ai_service, openai, "Generates text")
    Rel(ai_service, linkedin, "Scrapes data")

    Rel(ai_service, linkedin, "Scrapes data")

    Rel(sched_service, calendar, "Syncs events")
```

## 9. C4 Component Diagram: AI Sourcing Module

This diagram zooms into the **AI Engine Container**, specifically focusing on the **AI Sourcing Module** responsible for Use Case 1 (Sourcing & Screening).

### Component Breakdown

1.  **Requirement Analyzer:**
    *   Receives the Job Description from the API Gateway.
    *   Uses the LLM to extract key skills, experience levels, and "nice-to-haves."
    *   Converts these requirements into a vector embedding.

2.  **Candidate Scraper:**
    *   Triggered by the Requirement Analyzer.
    *   Connects to external sources (LinkedIn, GitHub) to fetch public profiles matching the criteria.
    *   Respects rate limits and `robots.txt`.

3.  **Matching Engine:**
    *   The core brain. It compares the Job Requirement Vector against Candidate Vectors stored in the Vector DB.
    *   Calculates a cosine similarity score ("Fit Score").
    *   Filters out candidates below a certain threshold (e.g., < 70%).

4.  **Outreach Manager:**
    *   Takes the top-ranked candidates.
    *   Prompts the LLM to generate a personalized email/message based on the candidate's specific profile and the job value proposition.
    *   Queues the message in the Communication Service.

5.  **Screening Bot:**
    *   Handles incoming replies via Webhooks.
    *   Maintains conversation state (context) in Redis.
    *   Evaluates candidate answers against "Knockout Criteria" defined in the Job Posting.

### Diagram

```mermaid
C4Component
    title Component Diagram for AI Sourcing Module

    Container(api_gateway, "API Gateway", "GraphQL", "Entry point for requests")
    ContainerDb(vector_db, "Vector DB", "Pinecone", "Stores candidate & job embeddings")
    ContainerDb(redis, "Redis Cache", "Redis", "Stores conversation state")
    Container(comm_service, "Comm Service", "Node.js", "Sends Emails/SMS")
    
    System_Ext(openai, "LLM Provider", "OpenAI API", "Generates text & embeddings")
    System_Ext(linkedin, "External Sources", "LinkedIn/GitHub", "Source of candidate data")

    Container_Boundary(ai_sourcing_module, "AI Sourcing Module") {
        Component(req_analyzer, "Requirement Analyzer", "Python", "Parses JDs & creates embeddings")
        Component(scraper, "Candidate Scraper", "Python", "Fetches external profiles")
        Component(matcher, "Matching Engine", "Python/NumPy", "Calculates Fit Scores")
        Component(outreach, "Outreach Manager", "Python", "Drafts personalized messages")
        Component(bot, "Screening Bot", "Python", "Handles chat interactions")
    }

    Rel(api_gateway, req_analyzer, "Triggers sourcing", "gRPC")
    
    Rel(req_analyzer, openai, "Generates embedding", "HTTPS")
    Rel(req_analyzer, scraper, "Passes search criteria", "Internal Call")
    
    Rel(scraper, linkedin, "Fetches profiles", "HTTPS")
    Rel(scraper, matcher, "Passes candidate data", "Internal Call")
    
    Rel(matcher, vector_db, "Queries similar vectors", "HTTPS")
    Rel(matcher, outreach, "Passes top candidates", "Internal Call")
    
    Rel(outreach, openai, "Generates email draft", "HTTPS")
    Rel(outreach, comm_service, "Queues message", "gRPC")
    
    Rel(api_gateway, bot, "Routes incoming msg", "gRPC")
    Rel(bot, redis, "Reads/Writes context", "TCP")
    Rel(bot, openai, "Evaluates response", "HTTPS")
    Rel(bot, comm_service, "Sends reply", "gRPC")
```
